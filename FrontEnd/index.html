<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Live Caption Overlay</title>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" />
    
    <link rel="stylesheet" href="style.css"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="caption-container">
        <div id="caption-box" class="caption-box">
            <p id="caption-output">Pressione INICIAR para comeÃ§ar a legendar...</p>
        </div>

        <div id="control-panel" class="control-panel hidden">
            <button id="startButton" class="control-button"><i class="fas fa-play"></i> INICIAR</button>
            
            <button id="pauseResumeButton" class="control-button" disabled>
                <i class="fas fa-pause"></i> PAUSAR
            </button>
            
            <button id="stopButton" class="control-button" disabled>
                <i class="fas fa-stop"></i> FINALIZAR
            </button>
            
            <button id="closeButton" class="control-button">
                <i class="fas fa-times"></i> FECHAR
            </button>
        </div>
    </div>
    <script>
        // *** IMPORTANTE: ENVOLVA TODO O SEU CÃ“DIGO DENTRO DE DOMContentLoaded ***
        // Isso garante que o JS sÃ³ tente buscar os elementos HTML APÃ“S eles existirem.
        document.addEventListener('DOMContentLoaded', () => {
            
            // Seu cÃ³digo JavaScript comeÃ§a aqui (AGORA FUNCIONARÃ):

            const { ipcRenderer } = require('electron');

            // As variÃ¡veis agora encontrarÃ£o os elementos no DOM
            const captionOutput = document.getElementById('caption-output');
            const startButton = document.getElementById('startButton');
            const pauseResumeButton = document.getElementById('pauseResumeButton');
            const stopButton = document.getElementById('stopButton');
            const controlPanel = document.getElementById('control-panel');
            const captionContainer = document.querySelector('.caption-container');
            
            // VariÃ¡veis de controle de Ã¡udio (WebSocket streaming)
            let audioStream;
            let isListening = false;
            let isPaused = false;
            let ws = null;
            let audioCtx = null;
            let processor = null;

            // --- ConfiguraÃ§Ãµes de TranscriÃ§Ã£o ---
            // WebSocket Vosk local (baixa latÃªncia)
            const VOSK_WS = 'ws://127.0.0.1:2700';
            const VOSK_SAMPLE_RATE = 16000; // sample rate esperado pelo Vosk
            // ----------------------------------------------------
            
            // --- FUNÃ‡Ã•ES DE CONTROLE DE INTERATIVIDADE (ELECTRON) ---
            // ... (Seu cÃ³digo de enableInteraction e disableInteraction) ...
            function enableInteraction() {
                ipcRenderer.send('set-ignore-mouse-events', false);
                controlPanel.classList.remove('hidden');
            }
            
            function disableInteraction() {
                ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
                controlPanel.classList.add('hidden');
            }

            // Throttled mousemove watcher: decide whether the window should ignore mouse
            // events (pass them through to underlying windows) depending on the element
            // under the cursor. If the element is effectively transparent to pointer
            // events, we tell the main process to forward events; otherwise keep the
            // window interactive.
            let lastIgnoreState = null;
            function parseAlphaFromBg(bg) {
                if (!bg) return 0;
                // bg formats: 'rgba(r, g, b, a)' or 'rgb(r, g, b)' or 'transparent'
                if (bg === 'transparent') return 0;
                const m = bg.match(/rgba?\(([^)]+)\)/);
                if (!m) return 1;
                const parts = m[1].split(',').map(s => s.trim());
                if (parts.length === 4) return parseFloat(parts[3]) || 0;
                return 1;
            }

            function shouldWindowIgnoreAtPoint(x, y) {
                const el = document.elementFromPoint(x, y);
                if (!el) return true; // nothing -> treat as transparent

                // If element explicitly opts out of pointer events, pass through.
                const pe = getComputedStyle(el).pointerEvents;
                if (pe === 'none') return true;

                // Walk up ancestors to check background alpha. If any ancestor provides
                // a non-zero background alpha, we consider the pixel opaque for our
                // purposes and keep the window interactive there.
                let node = el;
                while (node && node !== document.documentElement) {
                    const bg = getComputedStyle(node).backgroundColor;
                    const alpha = parseAlphaFromBg(bg);
                    if (alpha > 0) return false; // opaque-ish
                    node = node.parentElement;
                }
                // No ancestor provides an opaque background -> pass through.
                return true;
            }

            // simple throttle
            let mouseThrottleTimer = null;
            window.addEventListener('mousemove', (ev) => {
                if (mouseThrottleTimer) return;
                mouseThrottleTimer = setTimeout(() => {
                    mouseThrottleTimer = null;
                    try {
                        const wantIgnore = shouldWindowIgnoreAtPoint(ev.clientX, ev.clientY);
                        if (wantIgnore !== lastIgnoreState) {
                            ipcRenderer.send('set-ignore-mouse-events', wantIgnore, { forward: true });
                            lastIgnoreState = wantIgnore;
                        }
                    } catch (e) {
                        console.warn('ignore mouse detection failed', e);
                    }
                }, 50); // 20Hz
            }, { passive: true });


            // --- LÃ“GICA DE ÃUDIO: WebAudio -> PCM16 16k -> WebSocket (Vosk) ---
            function floatTo16BitPCM(float32Array) {
                const l = float32Array.length;
                const buffer = new ArrayBuffer(l * 2);
                const view = new DataView(buffer);
                let offset = 0;
                for (let i = 0; i < l; i++, offset += 2) {
                    let s = Math.max(-1, Math.min(1, float32Array[i]));
                    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                }
                return buffer;
            }

            function downsampleBuffer(buffer, inputSampleRate, outputSampleRate) {
                if (outputSampleRate === inputSampleRate) {
                    return buffer;
                }
                const sampleRateRatio = inputSampleRate / outputSampleRate;
                const newLength = Math.round(buffer.length / sampleRateRatio);
                const result = new Float32Array(newLength);
                let offsetResult = 0;
                let offsetBuffer = 0;
                while (offsetResult < result.length) {
                    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                    let accum = 0, count = 0;
                    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                        accum += buffer[i];
                        count++;
                    }
                    result[offsetResult] = accum / count;
                    offsetResult++;
                    offsetBuffer = nextOffsetBuffer;
                }
                return result;
            }

            async function startStreamingToVosk() {
                try {
                    ws = new WebSocket(VOSK_WS);
                    ws.binaryType = 'arraybuffer';

                    ws.onopen = () => {
                        console.log('WS connected to Vosk');
                        captionOutput.textContent = 'WS conectado ao Vosk';
                    };

                    ws.onerror = (evt) => {
                        console.error('WS error', evt);
                        captionOutput.textContent = 'Erro: conexÃ£o WS com Vosk';
                    };

                    ws.onclose = (evt) => {
                        console.warn('WS closed', evt);
                        captionOutput.textContent = 'ConexÃ£o WS fechada';
                    };

                    ws.onmessage = (evt) => {
                        try {
                            const data = JSON.parse(evt.data);
                            if (data.type === 'partial') {
                                captionOutput.textContent = data.partial;
                            } else if (data.type === 'final') {
                                captionOutput.textContent = data.text;
                            } else if (data.type === 'reset') {
                                captionOutput.textContent = '';
                            }
                        } catch (e) {
                            console.error('WS parse error', e);
                        }
                    };

                    captionOutput.textContent = 'Solicitando acesso ao microfone...';
                    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    captionOutput.textContent = 'Microfone permitido. Iniciando...';
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const inputSampleRate = audioCtx.sampleRate;
                    const source = audioCtx.createMediaStreamSource(audioStream);

                    processor = audioCtx.createScriptProcessor(2048, 1, 1);
                    source.connect(processor);
                    processor.connect(audioCtx.destination);

                    processor.onaudioprocess = (e) => {
                        try {
                            if (!ws || ws.readyState !== WebSocket.OPEN) return;
                            const inputData = e.inputBuffer.getChannelData(0);
                            const downsampled = downsampleBuffer(inputData, inputSampleRate, VOSK_SAMPLE_RATE);
                            const pcm16 = floatTo16BitPCM(downsampled);
                            ws.send(pcm16);
                        } catch (err) {
                            console.error('Erro no processamento de Ã¡udio:', err);
                        }
                    };
                } catch (err) {
                    console.error('Erro ao iniciar streaming Vosk:', err);
                    captionOutput.textContent = 'Erro: nÃ£o foi possÃ­vel iniciar streaming.';
                }
            }

            function stopStreamingToVosk() {
                try {
                    if (processor) {
                        processor.disconnect();
                        processor = null;
                    }
                    if (audioCtx) {
                        audioCtx.close();
                        audioCtx = null;
                    }
                    if (audioStream) {
                        audioStream.getTracks().forEach(t => t.stop());
                        audioStream = null;
                    }
                    if (ws) {
                        try { ws.close(); } catch(e) {}
                        ws = null;
                    }
                } catch (e) {
                    console.warn('Erro ao parar streaming:', e);
                }
            }
            
            // ... (Seu cÃ³digo de startRecording, stopProcessing, stopRecording) ...
            function startRecording() {
                captionOutput.textContent = 'Iniciando microfone...';
                startStreamingToVosk();
                isListening = true;
                isPaused = false;
                captionOutput.textContent = 'ðŸ”Š Ouvindo...';
                pauseResumeButton.disabled = false;
                stopButton.disabled = false;
                startButton.disabled = true;
                pauseResumeButton.innerHTML = '<i class="fas fa-pause"></i> PAUSAR';
            }
            
            function stopProcessing() {
                isListening = false;
                startButton.disabled = false;
                pauseResumeButton.disabled = true;
                stopButton.disabled = true;
                stopStreamingToVosk();
                captionOutput.textContent = captionOutput.textContent + ' [Reconhecimento encerrado.]';
            }

            function stopRecording() {
                // NÃ£o usamos MediaRecorder neste fluxo de streaming para Vosk.
                // Apenas encerra o processamento e oculta os controles.
                stopProcessing();
                disableInteraction();
            }
            
            // --- MANIPULADORES DE BOTÃƒO ---

            // A linha que falhava antes, agora funciona!
            startButton.addEventListener('click', () => { 
                enableInteraction(); 
                startRecording();
            });

            pauseResumeButton.addEventListener('click', () => {
                if (isListening) {
                    if (isPaused) {
                        // resume: re-start processing
                        startStreamingToVosk();
                        isPaused = false;
                        pauseResumeButton.innerHTML = '<i class="fas fa-pause"></i> PAUSAR';
                        captionOutput.textContent = 'ðŸ”Š Retomando a escuta...';
                    } else {
                        // pause: stop processing but keep UI
                        stopStreamingToVosk();
                        isPaused = true;
                        pauseResumeButton.innerHTML = '<i class="fas fa-play"></i> VOLTAR';
                        captionOutput.textContent = 'â¸ï¸ Pausado.';
                    }
                }
            });

            stopButton.addEventListener('click', () => {
                stopRecording(); 
            });
            
            // --- HABILITAR CONTROLES INICIAIS (Clique duplo na legenda para mostrar) ---
            captionContainer.addEventListener('dblclick', enableInteraction);

        }); // FIM do DOMContentLoaded
    </script>
</body>
</html>